# 数据结构与算法-lesson1

程序=数据结构+算法

## 评判算法优劣的维度

1. 时间复杂度 （流程决定）
2. 空间复杂度 （流程决定）
3. 常数项时间 （实现细节决定）

## 常见的常数时间的操作

- 常见的算术运算（+、-、*、/、%等）
- 常见的位运算（>> 、>>>、 <<、 |、 &、 ^等）
- 赋值、比较、自增、自减操作等
- 数组寻址操作

```
计算机是二进制，0 和 1 。<< 带符号右移操作 <<< 不带符号右移操作
数字 5 在计算机中表示为 00000000 00000000 00000000 00000101
5 进行 << ， 0 00000000 00000000 00000000 0000010
10000000 00000000 00110000 00000000 <<< 结果如下
1（拿原始位的值来补位） 10000000 00000000 00110000 0000000（原本是8个0 右移后，最右面的0没有了）
```

总结：
执行时间<font color="yellow" size=4>固定</font>的操作即为常数时间的操作。
反之，执行时间<font color="yellow" size=4>不固定</font>的操作都不是常数时间的操作。

```
一个无序数组的选择排序

-- 抹掉常数项和低阶项，只关心量阶 记作 【O（忽略掉系数的高阶项）】
-- 抹掉常数项（系数）的意义，当样本数量很大，趋近于∞（正无穷），常数项的影响很小了，没有意义了，这即为它要抹掉的意义。
```

## 时间复杂度

O(忽略掉系数的高阶项)

抹掉常数项和低阶项

### 时间复杂度为 O(n²）的常见算法

- 选择排序
- 冒泡排序
- 插入排序

### 常见的时间复杂度

排名从好到差

- O(1)
- O(㏒N)
- O(N)
- O（N*㏒N）
- O(N^2)   O(N^3)   O(N^4)   ...   O(N^K)
- O(2^N)   O(3^N)   O(4^N)   ...   O(K^N)
- O(N!)

## 操作数量PK样本数量

如何确定算法流程的总操作数量与样本数量之间的表达式关系?

1. 想象该算法流程所处理的数据状况，要按照最差情况来
2. 把整个流程彻底拆分为一个个基本动作，保证每个动作都是常数时间的操作
3. 如果数量为N，看看基本动作的数量和N是什么关系





## 额外空间复杂度

### 额外空间的定义

你需要实现一个算法流程，在实现算法流程的过程中，NIIT需要开辟一些空间来支持你的算法流程。

- 作为输入参数的空间，不算额外空间
- 作为输出结果的空间，不算额外空间

- 因为这些都是必要的，和实现目标有关的。所以都不算额外空间。

- 但除此之外，你的流程如果还需要开辟空间才能让你的流程继续下去。这部门的空间就是额外空间。

- 如果你的流程只需要开辟有限几个变量，额外空间复杂度就是O(1)

### 空间复杂度为O(1)的算法举例：

1. 选择排序
2. 冒泡排序
3. 插入排序

## 算法流程的常数项

我们会发现，时间复杂度这个指标，是忽略低阶项和所有常数系数的。

难道同样时间复杂度的流程算法，在实际运行中就一样好吗？

当然是

时间复杂度只是一个很重要的指标而已。如果两个时间复杂度一样的流程算法，你还是要在时间复杂度上拼优劣，就进入到拼常数时间的阶段，简称拼常数项。

```
时间复杂度一样，再进行比较？
-- 直接撇开理论分析，上大样本数据量跑，看实验执行结果（最有说服力)

-- +- (加减操作) 比 * / % （乘 除 取模） 运算快
-- 位运算 比 加减操作 运算快
```

## 最优解

面试、比赛、刷题中，一个问题的最优解是什么意思？

一般情况下，认为解决一个问题的算法流程，在时间复杂度的指标上，一定要尽可能低，先满足了时间复杂度最低这个指标后，使用最少的空间的算法流程，叫这个问题的最优解。

一般说，最优解都是忽略掉常数项这个因素的，因为这个因素只决定了实现层次的优化和考虑，而和怎么解决整个问题的思想无关。

```
c和c++ 的算法 时间给1s
java python 等时间会给 2 ~ 4 s

刷题正常不卡常数项时间
```



## 怎么看待算法，什么样算法

知道怎么算的算法（知道具体流程）

知道怎么试的算法（不知道具体流程，只能去试算）

## 对数器

### 你好烦，怎么办

你在网上找了某个公司的面试题，你想过了好久，感觉自己会做，但是你找不到在线测试，你好心烦  ...

你和朋友交流面试题，你想了好久，感觉自己会做，但是你找不到在线测试，你好心烦 ...

你在网上做笔试，但是前几个测试用例都过了，突然一个巨大无比数据量来了，结构你的代码报错了，如此巨大的数据量根本看不出哪错了，BUG 了，你好心烦

你好烦，你好烦，你好烦，怎么办？怎么办？
-- 认识对数器

### 认识对数器

1. 你想要测的方法a（复杂度上较好的方法）
2. 实现复杂度不好，但很容易实现的方法b
3. 实现一个随机样本生成器（不要依赖自己写的样本数据）
4. 把方法a和方法b跑相同的随机样本，看看得到的结果是否一致
5. 如果有一个随机样本比对结果不一致，打印出样本进行人工干预，debug都行，改对方法a和方法b
6. 当样本数量很多时，比多测试结果依然正确，你可以确定方法a已经正确